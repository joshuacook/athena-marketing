---
title: "Data Service (MVP)"
description: "Conventional CRUD façade over Context Service metadata"
section: "Services"
order: 3
draft: false
---

# Data Service (MVP)

A thin, conventional CRUD façade over the Context Service. Stores nothing independently; all records live in the Context Service as contexts with metadata.

## Overview

- ContextKind = table schema (managed by Context Service only)
- Context = row (record); `metadata` conforms to its kind's schema
- Data Service exposes table-like endpoints to create, update, and fetch records by ID
- Understanding is not exposed or queried by the Data Service

## Scope

- Operations: create, update, get-by-id only (no list, search, or joins)
- IDs: globally unique across all kinds (generated by Context Service)
- Schemas/kinds: created and evolved only via Context Service (not part of Data Service MVP)
- Deletes: optional/TBD (not included in MVP)

## Authentication & Guardrails

- Header: `Authorization: Bearer <API_KEY>` (required)
- Key resolves to a single `user_id` and one or more allowed `org_id`s
- If a key spans multiple orgs, include `X-Org-ID: <org_id>`; otherwise the org is derived from the key
- Data Service enforces org/user guardrails on every call and forwards `org_id` and `user_id` to the Context Service
- Client-supplied user identifiers are not trusted; identity comes from the API key

## Base URL

```
<data-service-base-url>
```

## Endpoints

### Create Record

`POST /tables/{kind}/rows`

Body:
```json
{
  "metadata": { "field": "value" }
}
```

Behavior:
- Validates presence of `metadata`; schema validation occurs in Context Service (errors are surfaced)
- Creates a Context of the given kind and returns the full record

Response `201`:
```json
{
  "id": "<uuid>",
  "kind": "post",
  "org_id": "<org>",
  "metadata": { "field": "value" },
  "created_at": "2025-09-10T12:00:00Z",
  "updated_at": "2025-09-10T12:00:00Z"
}
```

Example:
```bash
curl -X POST <data-service-base-url>/tables/post/rows \
  -H "Authorization: Bearer YOUR_API_KEY" \
  -H "X-Org-ID: YOUR_ORG_ID" \
  -H "Content-Type: application/json" \
  -d '{
    "metadata": {"title": "Hello", "author_id": "..."}
  }'
```

### Get Record by ID

`GET /tables/{kind}/rows/{id}`

Behavior:
- Fetches a record by ID scoped to the caller's `org_id`

Response `200`:
```json
{
  "id": "<uuid>",
  "kind": "post",
  "org_id": "<org>",
  "metadata": { "title": "Hello", "author_id": "..." },
  "created_at": "2025-09-10T12:00:00Z",
  "updated_at": "2025-09-10T12:00:00Z"
}
```

Example:
```bash
curl -X GET <data-service-base-url>/tables/post/rows/RECORD_ID \
  -H "Authorization: Bearer YOUR_API_KEY" \
  -H "X-Org-ID: YOUR_ORG_ID"
```

### Update Record (Partial)

`PATCH /tables/{kind}/rows/{id}`

Body:
```json
{
  "metadata": { "title": "Updated" }
}
```

Behavior:
- Partially updates `metadata`; schema validation occurs in Context Service
- No upsert in MVP (record must exist)

Response `200` returns the updated record.

Example:
```bash
curl -X PATCH <data-service-base-url>/tables/post/rows/RECORD_ID \
  -H "Authorization: Bearer YOUR_API_KEY" \
  -H "X-Org-ID: YOUR_ORG_ID" \
  -H "Content-Type: application/json" \
  -d '{
    "metadata": {"title": "Updated"}
  }'
```

## Error Model

Uniform error shape:
```json
{ "code": "string", "message": "string", "details": { } }
```

Common statuses:
- `401` invalid API key
- `403` org/user not authorized
- `404` record not found
- `422` schema/validation error (from Context Service)
- `409` conflict (reserved for future versioning)

## Division of Responsibility

- Data Service: auth, org/user guardrails, request/response shaping, error normalization
- Context Service: kind lifecycle and schema, validation, id generation, storage, understanding

## Work To Be Done (MVP)

### Data Service Work Items (MVP)

1) Authentication and Org Guardrails
- Implement API key middleware that resolves `user_id` and allowed `org_id`(s).
- Require `X-Org-ID` when the key spans multiple orgs; otherwise derive `org_id` from the key.
- Emit `401` for invalid keys; `403` when `X-Org-ID` not allowed.
- Acceptance: unit tests cover valid/invalid key, single/multi‑org paths.

2) Service-to-Service Call Contract
- On every Context Service call, include headers: `X-Org-ID`, `X-User-ID`, `X-Internal-Caller: data-service`, `X-Service-Auth: <secret>`.
- Read shared secret from config/env.
- Acceptance: integration tests assert headers are present; reject if missing org/user in DS layer.

3) Create Endpoint
- `POST /tables/{kind}/rows` validates body with `metadata` object present.
- Proxy to Context Service create; forward guardrail headers; return `201` with record.
- Map Context Service errors to Data Service error envelope and status codes.
- Acceptance: tests for happy path, 422 schema error passthrough, 403 org mismatch.

4) Get-by-ID Endpoint
- `GET /tables/{kind}/rows/{id}` proxies to Context Service read scoped by `org_id`.
- Acceptance: tests for found/not found, 403 when cross‑org attempted.

5) Update (Partial) Endpoint
- `PATCH /tables/{kind}/rows/{id}` validates `metadata` object; no upsert.
- Proxy to Context Service partial update; return updated record.
- Acceptance: tests for partial merge behavior surfaced from Context Service, 422 validation passthrough.

6) Error Normalization
- Implement uniform error envelope `{ code, message, details? }` for all DS responses.
- Acceptance: tests assert envelope and status codes for 401/403/404/422.

7) Configuration & Observability
- Config: Context Service base URL and `X-Service-Auth` secret via env.
- Minimal structured logging with request ID and org/user context.
- Acceptance: configuration documented; logs include `org_id`, `user_id`, route, status.

### Context Service Work Items (MVP)

1) Global IDs
- Ensure context `id` generation is globally unique (not per kind).
- Acceptance: unit test demonstrates uniqueness across kinds.

2) Org Scoping Enforcement
- Persist `org_id` on contexts; enforce that create/read/update operations require matching `org_id`.
- Acceptance: requests with mismatched `X-Org-ID` return `403`; matching org succeeds.

3) Schema Validation on Create/Update
- Validate `metadata` against the ContextKind schema; return `422` with field‑level details on violation.
- Acceptance: tests for missing required field, wrong type, enum violation.

4) Partial Update (PATCH) Semantics
- Support partial merge of `metadata` on update; do not allow upsert on non‑existent records.
- Re‑validate merged document against schema; return `422` on violation.
- Acceptance: tests for partial merge, rejection of unknown record (`404`), and validation paths.

5) Error Normalization
- Standardize errors to `{ code, message, details? }` with statuses `401`, `403`, `404`, `422`.
- Acceptance: tests assert shape and codes for representative failures.

6) Service-to-Service Trust Boundary
- Require and validate headers on DS calls: `X-Org-ID`, `X-User-ID`, `X-Internal-Caller: data-service`, `X-Service-Auth`.
- Reject calls missing/invalid internal headers; do not trust client‑supplied org/user.
- Acceptance: tests for missing/invalid `X-Service-Auth` → `401`; missing `X-Org-ID` → `400/403` (choose and document); invalid caller → `403`.

7) Minimal Telemetry
- Log caller, org, user, operation, and status for DS‑originated requests.
- Acceptance: logs include correlation fields and avoid sensitive data.

## Context Service Alignment Requirements

To support the Data Service façade, the Context Service MUST:

- IDs: generate globally unique `id` per context (kind-agnostic).
- Org scoping: persist `org_id` on every context and enforce that all reads/writes are scoped to the caller's `org_id`.
- Schema validation: validate `metadata` against the ContextKind schema on create and update; return `422` with details on violation.
- Partial updates: accept PATCH-style partial `metadata` updates (merge semantics) with schema validation; no upsert behavior.
- Error normalization: use standard HTTP statuses (`401`, `403`, `404`, `422`) with a consistent error body `{ code, message, details? }`.

Auth and trust boundary for service-to-service calls:

- Headers from Data Service to Context Service:
  - `X-Org-ID: <org_id>` (required)
  - `X-User-ID: <user_id>` (derived from API key; not client-controlled)
  - `X-Internal-Caller: data-service` and a shared secret header (e.g., `X-Service-Auth: <token>`) to prevent client spoofing
- Enforcement:
  - Reject if `X-Org-ID` is missing or does not match the target record's `org_id`.
  - Do not trust any client-supplied org/user headers; only trust Data Service internal headers.

## Out of Scope (MVP)

- List/search endpoints, cross-kind queries, joins
- Schema management and migrations
- Understanding management or queries
- Batch ingest/import flows
- Indexing/performance tuning
- Upsert and transactions

## Notes

- Kind names can be global or org-scoped; MVP behavior is unchanged either way
- Delete semantics are intentionally deferred; add `DELETE /tables/{kind}/rows/{id}` later if needed
